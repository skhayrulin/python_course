# Числа

Арифметические операции имеют ожидаемые приоритеты. При необходимости используются скобки.

1. Вычислить значение выражения 1 + 2\*3
2. Вычислить значение выражения (1 + 2)\*3
3. Вычислить значение выражения 1 + 2/3
4. Вычислить значение выражения 1 + 2/3 + 2
5. Вычислить значение выражения 1 + 2/(3 + 2)
6. Попробуйте разделить число на ноль, что выведется на экран

# Возведение числа в степень

Возведение целого числа в целую степень даёт целое число, если показатель степени  ≥0≥0 , и число с плавающей точкой, если он  < 0 < 0. Так что тип результата невозможно определить статически, если значение переменной n неизвестно.

6. Вычислить степень двойки разными способами (используйте встроенные функции пакета math pow и \*\* )
7. Вычислите степень 0.5 из отрицательного числа

# Различные операции

Операции приведение типов и вычисление остатков. 

1. Приведите целое число к числу с плавающей точкой (команда float(...))
2. Приведите число с плавающей точкой к целому (команда int(...))
3. Вычислите дробную часть числа
4. Вычислите остаток от деления (%)
5. Вычислите целое частное (//)
6. Как проверить, что число четное?

# Вывод/Ввод

В этом блоке рассматривается работа с функциями [print](https://docs.python.org/2/library/functions.html#print) и [input](https://docs.python.org/2/library/functions.html#input). Функция print обычно подается строка в качестве входной параметра строка передается в двойных "..." или одинарных '...'. Об остальных аргументах почитайте в документации или других источниках. Вам тоже могут пригодится некоторые строковые литералы 
`\n` - перевод строки на новую `\t` - табуляция.

1. Выведете строку приветствия с вашим именем (функция print(...))
2. Разработайте приложение принимающее на вход два числа и выводящее сумму этих чисел

# Переменные

Тип переменной в python определяется динамически информация о типе хранится в значение переменной, так, например, будет корректен следующий код

    x = 10      # здесь тип переменной int (целое число)
    x = 12.5    # теперь тип переменной стал float (число с плавающей точкой)
    x = "hello" # а теперь тип строковый str (строка или последовательность символов)
    x = True    # x теперь переменная булева типа принимает значение либо 0(False) либо 1(True)
    x = None    # пустая переменна слово None обозначает, что в переменной не хранится никакого значения

Как вы видели имя переменной не менялось и более того вы можете поверить, что это одна и тоже переменная, меняется только ее значение. Итак переменная задается следующим образом `var_name = value`. Переменная создается при ее инициализации. Можно комбинировать различные арифметические операции и присваивание например. Для удаления (очистки памяти занимаемой переменной) переменной и используйте функцию del.
    
    x += 10  # это эквивалентно x = x + 10
    x *= 10  # это эквивалентно x = x * 10
    x **= 10 # это эквивалентно x = x**10

1. Создайте целочисленную переменную и присвойте ей некоторое значение (например 123)
2. Создайте две переменные и присвойте значение первой второй ( операция равенства/присвоение = )
3. Создайте переменную как результат некоторой операции над числами (например 10 + 1)
4. Создайте переменную как результат некоторой операции над другими переменными (например var1 + var2)
5. Создайте переменную и удалите ее из контекста (операция del val)

# Циклы

Описываются следующими 2мя структурами.

    for cycle_var in  <iterable_object>:
        ...
    while <statment>:
        ...
В данном блоке могут быть полезны следующие функция `range(start, end, step)` подробнее [здесь](https://docs.python.org/2/library/functions.html#range). Функция `range(...)` создает объект который можно итерировать, первые два аргумента функции определяет интервал, третий аргумент определяет шаг т.е. каждый следующий объект получается из предыдущего следующим образом.
    
    next = prev + step
Чтобы прекратить выполнение цикла, не доходя до конца, можно воспользоваться ключевым словом `break` - при этом завершается ближайший цикл к слову `break`

    for i in range(1000):     # first loop
        for j in range(1000): # second loop
            print(j)
            break # завершится цикл  second loop
        print(i)
        break     # завершится цикл  first loop
        
В тоже время можно воспользоваться ключевым словом `continue` для продолжения работы цикла со следующей итерации
Пример:

    for i in range(1000):     # first loop
        print("Квадрат числа " + str(i**2))
        continue                            # при этом код следующий за словом continue не будет выполнятся
        print("куб числа " + str(i**3))
 
1. Выведите последовательность чисел 1..10 двумя различными типами цикла (while и for)
2. Выведите последовательность квадратов чисел от 1..100 различными типами цикла (while и for)
3. Выведите последовательность чисел от 112..133 в обратном порядке различными типами цикла (while и for)
4. Выведите последовательность Фибоначчи до 14ого числа
5. Выведете геометрическую последовательность до 15 числа (начиная с 1, шаг определяйте как хотите)
6. Посчитайте сумму предыдущей последовательности
7. Выведете матрицу некоторых числовых значений (на ваш выбор), двумя типами циклов (while, for)
8. Выведете некоторую диагональную матрицу
9. Выведете некоторую треугольную матрицу

# Условные операторы

Условные операторы представлены ключевыми словами:

* `if <expression>:` если, 
* `else:` тогда 
* `elif <expression>:` тогда если сокращенно <=> `else if`.

После описания условия оператор завершается двоеточием после чего идет код, выполняющийся в случае истинности условия. Обычно условные блоки записываются следующим образом

    if <expression>:
        x = 10
        x += 1
        print(x)
Что фактически означает, что если условие `<expression>` = True (истинно), то будет выполнятся код описанный в блоке `if`, а именно:

    x = 10
    x += 1
    print(x)
В случае ложности выражения `<expression>` = False (ложно) код описанный под условием не выполняется.Если вам необходимо разделить выполнение программы, тогда нужно использовать оператор `else` который тоже завершается двоеточием. Пример:

    if <expression>:
        x = 10
        x += 1
        print(x)
    else:
        x = 20
        x += 2
        print(x)
Т.е. если выражение `<expression>` = False (ложно), то выполняется код описанный в блоке `else`. Также можно использовать выражение `elif <expression>:`, которое по сути эквивалентно выражению `else if <expression>:`. Пример 
    
    n=4
    if n==1:
        print('один')
    elif n==2:
        print('два')
    elif n==3:
        print('три')
    else:
        print('много')

Для сравнения используются операторы 
* больше >
* меньше <
* равно ==
* не равно !=
* больше или равно >=
* меньше или равно <=

Логические выражения можно комбинировать с помощью `and`,`or`, `not` (эти операции имеют более низкий приоритет, чем сравнения). Если результат уже ясен из первого операнда, второй операнд не вычисляется. А вот так выглядит оператор if.

    if 1<2 and x<3:
        print('T')
    else:
        print('F')
        
Любопытная особенность питона: можно использовать привычные из математики сравнения вроде `xx<y` and `y<z`.

    1<2<=2 # эквивалентно 1<2 and 2<=2
    1<2<2  # эквивалентно 1<2 and 2<2

Есть и условные выражения:

    (0 if x<0 else 1)+1
Задачи:

1. Напишите условие проверяющее, что 200 больше 100 и меньше 300 двумя способами (с помощью and и or и как цепочку выражений)
2. Напишите условие проверяющей, что введено число больше 10 (число вводится при помощи команды input)
3. Напишите проверку на четность числа
4. Что будет результатом вычисления этого выражения `(0 if x<0 else 1)+1`, объясните почему
5. Коля купил N пирожков, а у Вани 100 пирожков напишите условие, проверяющее, что общее количество пирожков у ребят больше 100 и не меньше 150 или больше 200 но меньше 300. Количество пирожков для Коли вводится из командной строки (input).
6. Предположим, что вы ввели число от 1..5 тогда напишите ряд условий проверяющий что это за число и выводящий его слово на английском или русском обозначающий это слово (например 1-one или один)
7. Выведете таблицы истинности для выражений `x and y` `x or y` `x and not y` `(x or z) and (y or z)`
8. Как может выглядеть вечный цикл
        
## Циклы + Условные операторы

1. Напишите проверку число на простату (число является простым, если оно делится нацело только на себя и единицу)
2. Выведете все простые числа для заданного интервала
3. Выведете все числа в заданном интервале, позиция которых четна/нечетна (режим работы должен определятся из некоторой переменной которая при значении True должны выводить числа стоящие на четной позиции и наоборот).
4. Запустите вечный цикл при этом на каждом шаге цикла просите ввести некоторое значение пользователя (команда input(...)), если пользователь ввел букву q то ваша программа должна завершаться
5. Найдите сумму всех четных элементов ряда Фибоначчи, которые не превышают четыре миллиона.
6. Найдите сумму всех чисел меньше 1000, кратных 3 или 5.
7. Найдите все тройки пифагора для заданного интервала


# Функции

Функция позволяет выносить некоторые части кода в отдельную сущность, которая может применятся к различным данным многократно. Это позволяет сделать код намного более практичными и эффективным, как с точки зрения выполнения, так и с точки зрения оптимизации и поддержки. В языке python функция определение функции предваряется ключевым словом `def` (defenition - определение on eng.) после через пробел идет имя функции, затем в круглых скобках перечисляются параметры или аргументы функции через запятую и наконец объявление функции заканчивается двоеточием после чего на новой строке и с новым отступом идет блок в котором описывается функция. Пример функция вычисляющая факториал числа (число передается в функцию через список аргументов):    
    
    def fac(n):
        r = 1
        for i in range(2, n + 1):
            r *= i
        return r
    
    if __name__ == '__main__':
        fac(10) # вызов функции для числа 10
Функция может возвращать результат своих вычислений или нет, зависит от вашей реализации. Так например функция `fac` возвращает результат как факториал числа, для того что бы функция вернула результат используйте ключевое слово `return`. Аргументы функции могут быть умолчательными т.е. если функция вызывается без определения аргумента, то функция запустится на выполнением с умолчательным значением аргумента. для определения умолчательных аргументов при перечисление аргументов функции нужно указать умолчательное значение конкретного аргумента `def my_funс(arg1, arg2, arg3=10):`. Пример:
    
    def my_pow(n, power=2):
        return r**power
    
    if __name__ == '__main__':
        my_pow(10)    # вызов функции для числа 10 значение аргумента power будет равно 2
        my_pow(10, 4) # вызов функции для числа 10 значение аргумента power будет равно 4
Также возможно запускать функцию внутри функции - рекурсивно.

    def my_func():
        my_func()
Будьте внимательны, так как вы можете получить вечный цикл (на самом деле он не будет вечным ).
Задачи:

1. Напишите функцию не принимающую никаких аргументов, выводящую приветствие с вашим именем
2. Напишите функцию принимающую один аргумент строка, выводящую эту строку
3. Напишите функцию возводящую число в квадрат, возвращающее полученное значение
4. Напишите функцию вычисляющую факториал числа, возвращающее полученное значение
5. Напишите функцию вычисляющую N-ое число последовательности Фибоначчи
6. Напишите функцию вычисляющую N-ое число арифметической последовательности, шаг последовательности должен передаваться дополнительным аргументов (по умолчанию этот аргумент должен быть равен 1)
7. Определите функцию вычисляющую площадь треугольника при этом в качестве параметров должны передаваться значение высоты и основания
8. Определите функцию, которая принимает значение коэффициентов квадратного уравнения и выводит значение корней или предупреждение, что уравнение не имеет корней (в случае если детерминант оказался отрицательным)
9. Напишите функцию, которая для заданного параметров интервала, выводит значение, некоторой математической функции (например: sin, cos ... для этого не забудьте подключить модуль math import math)
10. Напишите функцию, которая для заданного в аргументах списка, возвращает как результат перевернутый список
11. Перепешите функцию для вычисления чисел фибоначи в рекурсивной форме
12. Напишите функцию вычисляющую N-ое число арифметической последовательности в рекурсивной форме
13. Написать функцию XOR_cipher, принимающая 2 аргумента: строку, которую нужно зашифровать, и ключ шифрования,  которая возвращает строку, зашифрованную путем применения функции XOR (^) над символами строки с ключом.    Написать также функцию XOR_uncipher, которая по зашифрованной строке и ключу восстанавливает исходную строку.


# Области видимости переменных

В Python, переменные, на которые только ссылаются внутри функции, считаются глобальными. Если переменной присваивается новое значение где-либо в теле функции, считается, что она локальная, и, если вам нужно, то нужно явно указывать её глобальной.

    x = 10
    def bar():
        print(x)
    bar()
    
    x = 10
    def foobar():
        global x
        print(x)
        x += 1
    foobar()
    
Это явное объявление требуется для того, чтобы напомнить вам, что (в отличие от внешне аналогичной ситуации с переменными класса и экземпляра), вы на самом деле, изменяете значение переменной во внешней области видимости:
Вы можете сделать подобную вещь во вложенной области видимости использованием ключевого слова nonlocal:

    def foo():
        x = 10
        def bar():
           nonlocal x
           print(x)
           x += 1
        bar()
        print(x)
    foo()

## Передача аргументов в функцию

Если при вызове функции подставим в качестве значения аргумента переменную, а в теле функции мы меняем значение аргумента, то то, что произойдет, зависит от того, с каким значение связана наша переменная. Если переменная связана с неизменяемым значением, например int, str, tulpe, то естественно, это значение не изменится. А вот если переменная связана со списком, словарем или классом, то значение связанного с переменной объекта изменится.


# Списки и работа с ними (срезки, генераторы)

Списки могут содержать объекты любых типов (в одном списке могут быть объекты разных типов). Списки индексируются с нуля. список создается при следующим образом

    x = [] # создали пустой список
    x = [100] # создали список с одним элементом 100

К списку применима операция индексации т.е. к каждому элементу списка можно обращаться по его соответствующему  номере в списке например:
    
    x = [1,2,3,4,5] # создали список из 5 элементов от 1 до 5
    print(x[0])
    print(x[4])
    
Результат:

    >>> 1
    >>> 5

Отрицательные индексы используются для счёта с конца: `s[-1]` - последний символ в списке, и т.д.Помимо индексации к список обладает рядом других функций с полным список можно познакомится в официальной [документации](https://docs.python.org/3/library/stdtypes.html#typesseq) краткий список операций 

Operation |	Result 
----------|----------------
s[i] = x | item i of s is replaced by x
s[i:j] = t | slice of s from i to j is replaced by the contents of the iterable t	 
del s[i:j] | same as s[i:j] = []	 
s[i:j:k] = t | the elements of s[i:j:k] are replaced by those of t	(1)
del s[i:j:k] | removes the elements of s[i:j:k] from the list	 
s.append(x) | appends x to the end of the sequence (same as s[len(s):len(s)] = [x])	 
s.clear() | removes all items from s (same as del s[:])	(5)
s.copy() | creates a shallow copy of s (same as s[:])	(5)
s.extend(t) or s += t | extends s with the contents of t (for the most part the same as s[len(s):len(s)] = t)	 
s *= n | updates s with its contents repeated n times	(6)
s.insert(i, x) | inserts x into s at the index given by i (same as s[i:i] = [x])	 
s.pop([i]) | retrieves the item at i and also removes it from s	(2)
s.remove(x) | remove the first item from s where s[i] == x	(3)
s.reverse() | reverses the items of s in place	(4)

Для перебора списка удобно использовать циклы
    
    x = [1,2,3]
    for i in x:
        print i

Результат
    
    >>> 1
    >>> 2
    >>> 3

Для того чтобы узнать длину списка удобно использовать встроенную функцию `len()` пример:
    
    x = [1,2,3]
    print(len(x))
    >>> 3
    
Если вы хотите проверить находится ли элемент в списке удобно использовать оператор `is`

    x = [1,2,3]
    1 in x
    >>>True

## Срезки (Slice)

Если вам необходимо выбрать какое-то подмножество списка, то удобно использовать срезки, которые позволяют извлекать подсписок списка. Синтаксис этого механизма выглядит следующим образом пример:
    
    x = [1,2,3,4,5,6]
    print(x[0:2])

Результат
    
    >>> [1,2]
    
Пример:

    x = [1,2,3,4,5,6]
    print(x[2:])
    print(x[:3])
    >>> [3,4,5,6]
    >>> [1,2,3]

Пример:
    x = [1,2,3]
    print(x[::-1])
    >>> [3,2,1]

Последний пример переворачивает список
   
    
## Генераторы

Можно строить список поэлементно.

    l=[]
    for i in range(10):
        l.append(i**2)
    print(l)
    
Но более компактно и элегантно такой список можно создать при помощи генератора списка (list comprehension). К тому же это эффективнее - размер списка известен заранее, и не нужно много раз увеличивать его. Опытные питон-программисты используют генераторы списков везде, где это возможно (и разумно).

    [i**2 for i in range(10)]
    [[i,j] for i in range(3) for j in range(2)]
    
В генераторе списков могут присутствовать некоторые дополнительные элементы, хотя они используются реже. Например, в список-результат можно включить не все элементы.

    [i**2 for i in range(10) if i!=5]
    
Создадим список случайных целых чисел.

    from random import randint
    l=[randint(0,9) for i in range(10)]
    print(l)

Функция sorted возвращает отсортированную копию списка. Метод sort сортирует список на месте. Им можно передать дополнительный параметр - функцию, указывающую, как сравнивать элементы.
    
    sorted(l)
    
    
## Кортежи 

Кортежи (tuples) очень похожи на списки, но являются неизменяемыми. Как мы видели, использование изменяемых объектов может приводить к неприятным сюрпризам.
Кортежи пишутся в круглых скобках. Если элементов  >1>1  или 0, это не вызывает проблем. Но как записать кортеж с одним элементом? Конструкция (x) абсолютно легальна в любом месте любого выражения, и означает просто x. Чтобы избежать неоднозначности, кортеж с одним элементом x записывается в виде (x,).

## Строки

Питон хорошо приспособлен для работы с текстовой информацией. В нём есть много операций для работы со строками, несколько способов записи строк (удобных в разных случаях). В современных версиях питона (3.x) строки юникодные, т.е. они могут содержать одновременно русские и греческие буквы, немецкие умляуты и китайские иероглифы.

### Задачи

1. Создайте список числовых значений от 0 до 100 (через циклы и генераторы)
2. Создайте список квадратов элементов предыдущего списка (через циклы и генераторы)
3. Создайте список, состоящий из четных элементов предыдущего списка (через циклы и генераторы)
4. Вот строка 'rewlkdfsklgjdflkjglkdsfjgkldfsjglkjeroitewuiotujdigjsdfklg;klsdfgkl;jsdfkl;gjldk;sfjgjlk;sdfjlk;gjsdfl;kgl;kdsfjgl;kjsdfl;kgjl;sdfkjg;lkjsdflbvjdfslkglkrewjhtiowerjutioerutopiytuilyhjdsfl;kghjl;sdkf;gjdffffffffflkgjlkdfjglkasjdfoitweigheripjgierglisjdfkjlghsdfkj;l;hgkljasdhfglk;hsdfkjlghlk;sdfhg;kljsdflkgjlk;sdfjgl;ksdfjl;kgjsdfl;kjglk;sdfjgkjsdfl;kgjs;dlkfjgoiw3eujtio34wuytiergoijherjhlgjsdflkjgkl;dfjgkl;sdfjkl;gjsdf;lkjg;lsjeriotuerl;kjdsfkl;jgh;lksdfjg;lksdfjg;lksdfkjg;lkjreopyulidsjfl;kghjs;ldkjg;lkkjr5l;h;kljyhkl;rirtiririiiiiiiiiiiiiierwtsj;kldfjg;lksdfjgl;ksdjfl;gj;lsdfjg;lk' - удалите из нее все повторяющиеся буквы и выведете строку уникальных букв
5. Как я буквенная подпоследовательность одинаковых символов самая длинная
6. Напишите функцию которая будет удалять заданную букву из строки и протестируйте ее на вышеприведенной строчке 
6. Вот список чисел - 2,3,3,45,4,23,43,54,34,5,32,423,4,23542354,3422,243,4,3,3,254,5643,3233,3,3,4,43,2,423,3,3,45,5,43,2,1,4,34234,34,3,342,23,4543,534,32423,23,4,4,4,3,423,3245,23,3,34254,235,234,5,235,4,345,235,23,5523,5,234,52,67,756,76,57,345,23,31,7,8,56,346,345,756,4343,754,674,8,568,9,65,34,3,5474,5687,56,2,3 - вычислите сумму этой последовательности
7. Найдите наибольший/наименьший элемент предыдущего списка
8. Отсортируйте предыдущий список
9. Напишите программу, которая спрашивает е пользователя как много чисел Фибоначчи нужно сгенерировать а затем генерирует их
10. сгенерируйте матрицу как список списков (через циклы и генераторы)
11. Напишите функцию транспонирования матрицы
12. Напишите функцию сложения матриц
13. Напишите функцию умножения матриц
14. Напишите функцию решения системы линейных уравнений методом Гаусса. Коэффициента уравнения задаются матрицей вектор неизвестных - вектором соответственно. [метод Гаусса и как его запрогать можно найти здесь](https://ru.wikipedia.org/wiki/%D0%9C%D0%B5%D1%82%D0%BE%D0%B4_%D0%93%D0%B0%D1%83%D1%81%D1%81%D0%B0) (можно не делать если кажется слишком сложным)


## Множества

В соответствии с математическими обозначениями, множества пишутся в фигурных скобках. Элемент может содержаться в множестве только один раз. Порядок элементов в множестве не имеет значения, поэтому питон их сортирует. Элементы множества могут быть любых типов. Множества используются существенно реже, чем списки. Но иногда они бывают весьма полезны. Например, когда я собирался делать апгрейд системы на сервере, я написал на питоне программу, которая строила множество пакетов, установленных в системе до апгрейда; множество пакетов, имеющихся на инсталляционных CD; имеющихся на основных сайтах с дополнительными пакетами, и т.д. И она мне помогла восстановить функциональность после апгрейда. 
Чтобы создать множество из списка достаточно вызвать функцию [`set()`](https://docs.python.org/3/tutorial/datastructures.html#sets) которой в качестве аргуемнта подается итерируемй объект 
    
    x = [1,2,3,4,1,2,1,2]
    y = set(x)
    print(y)
    {1,2,3,4}
Как видно из примера в множестве останутся только уникальные объекты таким обазом set удобно использовать для построения уникальных последовательностей.


## Словари

Словарь содержит пары ключ - значение (их порядок несущественен). Это один из наиболее полезных и часто используемых типов данных в питоне.

    d={'one':1,'two':2,'three':3}

Можно узнать значение, соответствующее некоторому ключу. Словари реализованы как хэш-таблицы, так что поиск даже в больших словарях очень эффективен. В языках низкого уровня (например, C) для построения хэш-таблиц требуется использовать внешние библиотеки и писать заметное количество кода. В скриптовых языках (perl, python, php) они уже встроены в язык, и использовать их очень легко.

    print(d['two'])
    print(d['four'])
    ---------------------------------------------------------------------------
    KeyError                                  Traceback (most recent call last)
    <ipython-input-34-a0944cd0c15b> in <module>()
    ----> 1 d['four']

    KeyError: 'four'
Можно проверить есть ли ключ в словаре
    
    print('one' in d, 'four' in d)
    
Словарь может быть также задан при помощи генератора словаря:

    {a:a**2 for a in range(1, 10)}
    
Чтобы пробежаться по словарю можно таже использовать встроенную функцию `items()`, которая возвращает список кортежей (key, value). Также есть функции `keys()` и `values()`, который возвращают списки ключей и значений соответственно.

### Задачи:
1. Постройте список с повторяющимися значениями и создайте из него множество
2. Определите основные теоретико множественые операции, объединение, пересечение, разность двух множеств
3. Расширьте ваши функции для работы с бесконечно большим колличеством множеств.
4. Как можно просто в этой строке 'rewlkdfsklgjdflkjglkdsfjgkldfsjgliiiiiiiiiierwtsj;kldfjg;lksdfjgl;ksdjfl;gj;lsdfjg;lk' -  удалить все повторяющиеся эллементы
5. Предположим вы вводите строку, используя стандартную функцию input() посчитайте и вывидете какое колличество разных символов в этой строке
6. напишите функцию `concatenate(dict1, dict2)`, которая объединяет два словаря и вовращает результат, выведете результат

# Некоторые задачи по биоинформатике. Любезно предоставленные Максимом Ри, за что ему и спасибо!
1. Скачать нуклеотидную последовательность хромосомы Y в fasta формате (версия генома – hg38, ссылка заархивированного [файла](http://hgdownload.soe.ucsc.edu/goldenPath/hg38/chromosomes/chrY.fa.gz)). Посчитать количество нуклеотидов (A, C, G и T) на обратной цепи.
2. Разбить файл в fasta формате на два файла в fasta формате. Содержание каждого файла соотвествует нуклеотидным последовательностям с именами left или right.
    Input file in fasta format:  
    >Name_1_left  
    ATACATCGTACGTTGATCGATGCTAGCTAGGGG  
    >Name_2_right  
    AAATATATTTATATGATAGATGATGATTTTTC  
    >Name_1_right  
    AAATTATATATTATAGAGGAGCGCGAGA  
    >Name_3_left  
    ATACATCGTACGTTGATCGATGCTAGCTAGCCCCCCCC  
    >Name_3_right  
    AAATATATTTATATGATAGATGATGATTTTT  
    >Name_2_left  
    AAATTATATATTATAGAGGAGCG  

    Ouput of file 1 in fasta format:  
    >Name_1_left  
    ATACATCGTACGTTGATCGATGCTAGCTAGGGG  
    >Name_2_left  
    AAATTATATATTATAGAGGAGCG  
    >Name_3_left  
    ATACATCGTACGTTGATCGATGCTAGCTAGCCCCCCCC  
  
    Ouput of file 2 in fasta format:  
    >Name_1_right  
    AAATTATATATTATAGAGGAGCGCGAGA  
    >Name_2_right  
    AAATATATTTATATGATAGATGATGATTTTTC  
    >Name_3_right  
    AAATATATTTATATGATAGATGATGATTTTT  
3. Перевести fastq формат в fasta формат. Проделать обратную процедуру приписав качество \*.  
    Input file in fastq format:  
    @Name_1  
    ATACATCGTACGTTGATCGATG  
    \+  
    !!\*CCC%%%%!%%%%!!679CCC  

4. Скачать координаты транскриптов (версия генома hg38, описание [таблицы](https://genome.ucsc.edu/cgi-bin/hgTables), ссылка заархивированного [файла](http://hgdownload.soe.ucsc.edu/goldenPath/hg38/database/knownGene.txt.gz). Объединить пересекающиеся координаты транскриптов с учетом стренда и названия хромосом.  
    Example of input file:  
    chr1   +  10   100  
    chr1   +  15   300  
    chrX   -   66   89  
    chrX   +  50   100  
    chrX   -   10   500  
  
    Output file:  
    chr1   +  10   300    
    chrX   -   66   89  
    chrX   +  50   100  
    chrX   -   10  500  
    **Дополнительно**. Наличие стренда и хромосомы сделать в качестве аргумента python `./program.py input_file output_file strand chr`. Если отсутствует 3 (strand) и 4 (chr) аргумент, то объединять без учета стренда и хромосомы. Если отсутствует 3 (strand) аргумент, то объединять без учета стренд, но с учетом хромосомы. Если отсутствует 4 (chr) аргумент, то объединять без учета хромосомы, но с учетом стренда. Если присутствует 3 (strand) и 4 (chr) аргумент, то объединять с учетом стренда и хромосомы.
5. Имеется два списка генов. Найти общий список генов и уникальные списки генов.  
    List1:  
    ABL  
    AKT1  
    AKT2  
    SOX2  
  
    List2:  
    AKT3  
    ABL  
    NANOG  
    AKT2  
6. Посчитать количество уникальных генов в списке  
    List of input file:  
    ABL  
    AKT1  
    AKT2  
    SOX2  
    NANOG  
    SOX2  
    AKT2  
    EMX2  
    AKT1  
    AKT3  
    NANOG  
  
    List of output file:  
    ABL           1  
    AKT1         2  
    AKT2         2  
    SOX2         2  
    NANOG    2  
    EMX2        1  
    AKT3         1  

# ООП
Питон является развитым объектно-ориентированным языком. Всё, с чем он работает, является объектами - целые числа, строки, словари, функции и т.д. Каждый объект принадлежит определённому типу (или классу, что одно и то же). Класс тоже является объектом. Классы наследуют друг от друга. Класс object является корнем дерева классов - каждый класс наследует от него прямо или через какие-то промежуточные классы.
    
    object,type(object)
    >>> (object, type)
    
Функция dir возвращает список атрибутов класса.

    dir(object)
    >>> ['__class__',
         '__delattr__',
         '__dir__',
         '__doc__',
         '__eq__',
         '__format__',
         '__ge__',
         '__getattribute__',
         '__gt__',
         '__hash__',
         '__init__',
         '__le__',
         '__lt__',
         '__ne__',
         '__new__',
         '__reduce__',
         '__reduce_ex__',
         '__repr__',
         '__setattr__',
         '__sizeof__',
         '__str__',
         '__subclasshook__']
Атрибуты, имена которых начинаются и кончаются двойным подчерком, используются интерпретатором для особых целей. Например, атрибут `__doc__` содержит док-строку.
    
    object.__doc__
    >>> 'The most base type'
    help(object)
    Help on class object in module builtins:

    class object
     |  The most base type
     
## Классы
Вот простейший класс. Поскольку не указано, от чего он наследует, он наследует от object.
    
    class MyClass:
        pass
Создать объект какого-то класса можно, вызвав имя класса как функцию (возможно, с какими-нибудь аргументами). Мы уже это видели: имена классов int, str, list и т.д. создают объекты этих классов.

    o=A()
    o,type(o)
    >>> (<__main__.A at 0x7f01f8124278>, __main__.A)
У только что созданного объекта o нет атрибутов. Их можно создавать (и удалять) налету.
    
    o.x=1
    o.y=2
    o.x,o.y
    >>> (1, 2)
    o.z
    >>> ---------------------------------------------------------------------------
        AttributeError                            Traceback (most recent call last)
        <ipython-input-10-c8c0d478b237> in <module>()
        ----> 1 o.z

        AttributeError: 'A' object has no attribute 'z'
    del o.y
    o.y
    >>>---------------------------------------------------------------------------
        AttributeError                            Traceback (most recent call last)
        <ipython-input-11-68acd6859c06> in <module>()
              1 del o.y
        ----> 2 o.y

        AttributeError: 'A' object has no attribute 'y'
Такой объект похож на словарь, ключами которого являются имена атрибутов: можно узнать значение атрибута, изменить его, добавить новый или удалить старый. Это и неудивительно: для реализации атрибутов объекта используется именно словарь.
    
    o.__dict__
    >>> {'x': 1}
Класс вводит пространство имён. В описании класса мы определяем его атрибуты (атрибуты, являющиеся функциями, называются методами). Потом эти атрибуты можно использовать как Class.attribute. Принято, чтобы имена классов начинались с заглавной буквы.
Вот более полный пример класса. В нём есть док-строка, метод f, статический атрибут x (атрибут класса, а не конкретного объекта) и статический метод getx (опять же принадлежащий классу, а не конкретному объекту).

    class S:
        'Простой класс'

        x=1

        def f(self):
            print(self)

        @staticmethod
        def getx():
            return S.x
Заклинание тёмной магии, начинающееся с @, называется декоратором. Запись

    @dec
    def fun(x):
        ...
эквивалентна

    def fun(x):
        ...
    fun=dec(fun)
То есть dec - это функция, параметр которой - функция, и он возвращает эту функцию, преобразованную некоторым образом. Мы не будем обсуждать, как самим сочинять такие заклинания - за этим обращайтесь в Дурмстранг. Функция dir возвращает список атрибутов класса. Чтобы не смотреть снова на атрибуты, унаследованные от object, мы их вычтем.
## Наследование
## Инкапсуляция
## Полиморфизм
# Финальное задание
Напишите программу "калькулятор" программа должна быть спасобной обрабатывать арифмитические выражения и выводить результат
например ввод:

    1 + 2
    >>> 3
    
Также программа должна быть способна сохранять переменые, например ввод:
    
    x=2*(4+2)
    >>> x = 12

После ввода новой переменной калькулятор должен быть способен работать с этими переменными пример:
    
    y = 12
    x = 10
    z = x * y
    z
    >>> 120
Калькулятор должен быть способен создавать функции. Определяться они должны следующим образом, сначала идет зарезервированное слово `function`, затем имя функции после чего в скобках черех запятую перечесляются аргументы и после закрывающей скобки и двоеточия идет определение функции как одного арифмитического выражения, пример:
    
    function pow2(x): x*x
После этого заявленная функция должна быть доступна т.е.
    
    pow2(3)
вывод
    
    9
Также должна быть возможность посмотреть все созданные переменные в контексте программы например с помощь зарезервированного слова print - выводит список всех перееменных и функций  программе:
    
    print
    >>> x - переменная
        y - переменная
        z - переменная
        pow2 - функция

Если пользователь ввел слово `quit` программа должна завершать свое выполнение. Если переменная или функция еще не поределена, то должно выводится сообщение, что мы пытаемся исспользовать еще не поределенную переменную или функцию. Такое же поведение должно быть при неверном арифмитическом выражении например деление на ноль.
**TO BE CONTINUED**
    
